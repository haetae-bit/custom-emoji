---
import { actions, isInputError } from "astro:actions";
import { AtUri } from "@atproto/syntax";
import { getPdsAgent } from "@fujocoded/authproto/helpers";
import { safecode } from "../utils/types";

const loggedInUser = Astro.locals.loggedInUser;
if (!loggedInUser) {
  return "Uh oh, you're not logged in!";
}

const agent = await getPdsAgent({ loggedInUser });
const response = await agent?.com.atproto.repo.listRecords({
  collection: "com.fujocoded.astrolabe.emojiset",
  repo: loggedInUser.did,
});
const emojiSets = response?.data.records ?? [];
const list = (emojiSets.length > 0) ? "emoji-sets" : undefined;

const result = Astro.getActionResult(actions.addEmoji);
const errors = isInputError(result?.error) ? result.error.fields : {};
---
<form action={actions.addEmoji} method="post" enctype="multipart/form-data" aria-errormessage={result?.error ? "form-error" : undefined}>
  <fieldset>
    <legend>Metadata</legend>

    <div class="control">
      <label for="shortcode">Shortcode</label>
      <input type="text" name="shortcode" id="shortcode" pattern={safecode.source} aria-describedby="shortcode-note" aria-errormessage={errors.shortcode ? "shortcode-error" : undefined} required />
      {errors.shortcode && (
        <p id="shortcode-error">{errors.shortcode.join(",")}</p>
      )}
      <p id="shortcode-note">Must start and end with a lowercase English letter or number, no spaces are allowed, but you can use dash (<code>-</code>) or underscore (<code>_</code>)</p>
    </div>
    
    <div class="control">
      <label for="fallback">Fallback</label>
      <input type="text" name="fallback" id="fallback" aria-describedby="fallback-note" aria-errormessage={errors.fallback ? "fallback-error" : undefined} />
      {errors.fallback && (
        <p id="fallback-error">{errors.fallback.join(",")}</p>
      )}
      <p id="fallback-note">In case an app doesn't support custom emojis, use standard emojis (like ‚ù§Ô∏è or üòÄ) as a fallback</p>
    </div>
  </fieldset>

  <fieldset>
    <legend>Image</legend>

    <div class="control">
      <label for="image">Upload</label>
      <div id="preview"></div>
      <div id="image-upload">
        <input type="file" name="image" id="image" accept="image/*" aria-describedby="image-note" aria-errormessage={errors.image ? "image-error" : undefined} required />
        <button id="image-reset" type="button">Clear</button>
      </div>
      {errors.image && (
        <p id="image-error">{errors.image.join(",")}</p>
      )}
      <p id="image-note">Must use image files, such as ".png", ".webp", or ".svg"</p>
    </div>

    <div class="control">
      <label for="alt">Alternative text</label>
      <input type="text" name="alt" id="alt" aria-describedby="alt-note" aria-errormessage={errors.alt ? "alt-error" : undefined} />
      {errors.alt && (
        <p id="alt-error">{errors.alt.join(",")}</p>
      )}
      <p id="alt-note">Describe what the emoji looks like for non-sighted users or when the image fails to load</p>
    </div>

    <div class="control">
      <label for="description">Description</label>
      <textarea name="description" id="description" aria-describedby="description-note" aria-errormessage={errors.description ? "description-error" : undefined} rows="2"></textarea>
      {errors.description && (
        <p id="description-error">{errors.description.join(",")}</p>
      )}
      <p id="description-note">Optional, you can write notes for what the emoji is supposed to convey</p>
    </div>
  </fieldset>

  <fieldset>
    <legend>Set</legend>

    <div class="control">
      <label for="collection">Name</label>
      <input 
        type="text" 
        name="collection" id="collection" 
        pattern="^[a-zA-Z0-9_~.:-]{1,512}$" 
        list={list} aria-controls={list} 
        aria-describedby="collection-note" 
        aria-errormessage={errors.collection ? "collection-error" : undefined} 
        aria-expanded="false" 
      />
      {emojiSets.length > 0 && (
        <datalist id="emoji-sets">
          {emojiSets.map(set => {
            const { rkey } = new AtUri(set.uri);
            return (
              <option value={rkey}>{rkey}</option>
            );
          })}
        </datalist>
      )}
      {errors.collection && (
        <p id="collection-error">{errors.collection.join(",")}</p>
      )}
      <p id="collection-note">You can either add to an existing emoji set or create a new one</p>
    </div>
    
    <div class="control">
      <label>
        Want to add a source?
        <input type="checkbox" name="sourceCheck" id="source-check" aria-controls="source-toggle" />
      </label>
    </div>
    
    <div id="source-toggle" class="control">
      <label for="source">Source</label>
      <input type="url" name="source" id="source" aria-describedby="source-note" aria-errormessage={errors.source ? "source-error" : undefined} />
      {errors.source && (
        <p id="source-error">{errors.source.join(",")}</p>
      )}
      <p id="source-note">Optional, this can be a valid URL to the artist or original source of the emoji set</p>
    </div>
    
    <div class="control">
      <label for="set-description">Description</label>
      <textarea name="setDescription" id="set-description" rows="2" aria-errormessage={errors.setDescription ? "set-description-error" : undefined}></textarea>
      {errors.setDescription && (
        <p id="set-description-error">{errors.setDescription.join(",")}</p>
      )}
    </div>
  </fieldset>

  <button type="submit">Upload</button>
  {result?.error && (
    <p id="form-error">{result.error}</p>
  )}
</form>

<style>
  form {
    margin-top: var(--size-2);
    display: flex;
    flex-direction: column;
    gap: var(--size-4);
    container: form / inline-size;
  }
  
  fieldset {
    display: flex;
    flex-direction: column;
    gap: var(--size-3);
    border: var(--border-size-2) solid var(--border-color);
    border-radius: var(--radius-2);

    legend {
      padding-inline: var(--size-2);
    }
  }

  .control {
    display: grid;
    grid-auto-flow: row;
    gap: var(--size-1);
    
    > * {
      width: 100%;
      max-width: calc(100cqw - (var(--size-3) * 2) - var(--border-size-2));
      contain: layout inline-size;
    }
  }

  #preview {
    display: flex;
    align-self: center;
    justify-content: center;
    max-height: 100px;
    
    img { object-fit: contain; }
  }

  #image-upload {
    display: flex;
    gap: var(--size-2);

    input[type="file"] {
      width: 100%;

      &::file-selector-button {
        --button-color: var(--accent);
        font: inherit;
        background-color: var(--button-color);
        padding: 0.35rem 0.75rem;
        margin: -0.2rem 0.75rem -0.25rem -0.6rem;
        border: none;
        border-radius: var(--radius-2);
        box-shadow: 0 var(--size-1) color-mix(in oklab, var(--button-color) 80%, var(--gray-12));
        transform: translateY(calc(var(--size-1) * -1));
        transition: all .5s var(--ease-bounce-2);
      }
    }

    input[type="file"]::file-selector-button:hover {
      background-color: color-mix(in oklab, var(--button-color) 92%, var(--gray-12));
      box-shadow: 0 0.2rem color-mix(in oklab, var(--button-color) 75%, var(--gray-12));
      transform: translateY(calc((var(--size-1) * -1) + 0.05rem));
    }

    input[type="file"]::file-selector-button:active {
      box-shadow: 0 0 transparent;
      transform: translateY(0);
    }

    @container (width < 560px) {
      display: flex;
      flex-flow: column nowrap;
    }

    @media screen and (prefers-reduced-motion: reduce) {
      transition: all .5s var(--ease-2);
    }
  }

  #source-toggle {
    opacity: 0;
    height: 0;
    margin-top: calc(var(--size-4) * -1);
    overflow: hidden;
  }

  .control:has(#source-check:checked) ~ #source-toggle {
    opacity: 1;
    height: fit-content;
    margin-top: unset;
    overflow: unset;
  }

  p[id$="-note"] { color: var(--subtle-text); }
  p[id$="-error"] { color: color-mix(in oklab, var(--red-8) 90%, var(--text)); }
</style>

<script>
  import { IMAGE_TYPES } from "../utils/types";
  const input = document.getElementById("image") as HTMLInputElement;
  const reset = document.getElementById("image-reset") as HTMLButtonElement;
  const preview = document.getElementById("preview");

  input.addEventListener("change", (e) => {
    clearImage();
    
    const target = e.target as HTMLInputElement;
    const file = target.files?.item(0);
    
    if (file && IMAGE_TYPES.includes(file.type)) {
      const image = document.createElement("img");
      image.src = URL.createObjectURL(file);
      image.alt = file.name;
      preview?.appendChild(image);
    }
  });

  reset.addEventListener("click", (e) => {
    e.preventDefault();
    input.value = "";
    clearImage();
  });

  function clearImage() {
    while (preview?.firstChild) {
      const image = preview.getElementsByTagName("img")[0];
      if (image) {
        image.addEventListener("load", () => {
          URL.revokeObjectURL(image.src);
        }, { once: true });
      }
      preview.removeChild(preview.firstChild);
    }
  }
</script>